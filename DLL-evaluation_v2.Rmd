---
title: "DLL-ES IRT Analysis and Recommendations"
author: "George Kachergis"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load-fitted-IRT-models, echo=F, message=F}
require(here)
require(mirt)
require(tidyverse)
require(gridExtra)

# use combined WS+WG data, or just WS?
load(here("data/eng_ws_wg_mod_2pl.Rds"))
coefs = list(en = coefs_2pl)
fscores = list(en = fscores_2pl)
mods = list(en = mod_2pl)

load(here("data/sp_wg_ws_mod_2pl.Rds"))
coefs$sp = coefs_2pl
fscores$sp = fscores_2pl
mods$sp = mod_2pl
rm(coefs_2pl, fscores_2pl, mod_2pl)
```

```{r load-cdi-short-forms, echo=F, message=F}
wg_short_en <- read_csv(here("DLL/eng-wg-short.csv")) # 89
ws_short_enA <- read_csv(here("DLL/eng-ws-shortA.csv")) # 100
#ws_short_enB <- read_csv(here("DLL/eng-ws-shortB.csv")) # 100 - note they did not use this one

#length(intersect(wg_short_en$word, coefs$en$definition)) # all match

#length(intersect(ws_short_enA$word, coefs$en$definition)) # all match, but:
# should "swing" (in Fenson2000) be (action) or (object) -- I made it object, since surrounded by nouns

#length(intersect(ws_short_enB$word, coefs$en$definition)) # all match
# replaced 'fish' with fish (animal) since surrounded by animals;
# 'chicken' -> chicken (food) given list context
# replaced 'feet' with 'foot' ...
# replaced 'drink' with drink (action)

# Spanish short forms
wg_short_sp <- read_csv(here("DLL/spanish-wg-short.csv"))
ws_short_sp <- read_csv(here("DLL/spanish-ws-short.csv"))
#(intersect(wg_short_sp$word, coefs$sp$definition)) # 102 - tambien not in wordbank
# 102 - wordbank errors: comer(se), adios (accent not on i), ver(se) ?, vasos (why plural?)
#setdiff(wg_short_sp$word, coefs$sp$definition)
#length(intersect(ws_short_sp$word, coefs$sp$definition)) # 99
#setdiff(ws_short_sp$word, coefs$sp$definition) # oir not in wordbank
```


## Goals

The goals are 1) to create a word list that is informative about both English and Spanish vocabulary size and 2) to ensure that there are sufficient doublets to estimate lexical overlap.
On an IRT view, we can't perfectly assess 2 (at least not without better bilingual CDI data), but we can assess criterion 1 - that is, we can look at whether the reduced word list is a good sub-test for the full CDI in each language. 
Our original concern was that the current DLL-ES test might not perform well for older or high ability kids due to the lack of abstract words, and we can test this formally.

The DLL lists are meant to be used together with the original English and Spanish MCDI short forms.

```{r load-all-DLL-lists, echo=F, message=F}
dll1short_raw <- read_csv(here("DLL/Sandy/DLL-ES Supplement Words - DLL-ES Short Form Supplements (Level 1).csv")) %>% 
  rename(english=`English Word`, 
         spanish=`Spanish Word`) 
dll2short <- read_csv(here("DLL/Sandy/DLL-ES Supplement Words - DLL-ES Short Form Supplements (Level 2).csv")) %>% 
  rename(english=`English Word`, 
         spanish=`Spanish Word`) 

# Level 1 exclusions: examine to see if we find some equal difficulty, informative matches?
dll1exclusions <- read_csv(here("DLL/Sandy/DLL-ES Supplement Words - DLL-ES Long Form Excluded Matches (Level 1).csv")) %>% 
  rename(english=`English Word`, 
         spanish=`Spanish Word`) # 94
dll2exclusions <- read_csv(here("DLL/Sandy/DLL-ES Supplement Words - DLL-ES Long Form Excluded Matches (Level 2).csv")) %>% 
  rename(english=`English Word`, 
         spanish=`Spanish Word`) # 210

dll1long <- read_csv(here("DLL/Sandy/DLL-ES Supplement Words - DLL-ES Long Form Supplement (Level 1).csv")) %>% 
  rename(english=`English Word`, 
         spanish=`Spanish Word`) 
dll2long <- read_csv(here("DLL/Sandy/DLL-ES Supplement Words - DLL-ES Long Form Supplement (Level 2).csv")) %>% 
  rename(english=`English Word`, 
         spanish=`Spanish Word`) 
```

Now we need to match the DLL words to the wordbank items for which we have IRT parameters.

```{r match-english-words, echo=F, message=F}

# use with EN WG short form (12-18 mos)
#dll1ENshort <- read_csv(here("DLL/DLL-ES1-short-English.csv")) # 79 items (81 after splitting defs)

dll1short <- dll1short_raw %>% # this is now 168 items...it has the WG short form included
  mutate(english = tolower(english)) %>%
  mutate(english = case_when(english == 'i' ~ 'I',
                          english == 'tv (television)' ~ 'TV',
                          english == 'water' ~ 'water (beverage)',
                          english == 'grandma (or word used in your family)' ~ 'grandma*',
                          english == 'mommy (or word used in your family)' ~ 'mommy*',
                          english == 'choo choo (train sound)' ~ 'choo choo',
                          english == 'patty cake' ~ 'pattycake',
                          english == 'bye or bye bye' ~ 'bye',
                          english == 'teddy bear' ~ 'teddybear',
                          english == 'his/her' ~ 'his', # hers ?
                          english == 'to have' ~ 'have',
                          english == 'shh' ~ 'shh/shush/hush',
                          english == 'to sit' ~ 'sit',
                          english == 'to be' ~ 'be',
                          english == 'put, put on' ~ 'put',
                          english == 'to write' ~ 'write',
                          english == 'arms' ~ 'arm',
                          english == 'church (or word used in your family)' ~ 'church*',
                          english == 'want' ~ 'wanna/want to',
                          english == 'in' ~ 'inside/in', # into ?
                          TRUE ~ english))

dll1ENshort_num_matching = length(intersect(dll1short$english, coefs$en$definition)) 
# 75/81 (GK version)
# 160/168 (Sandy)
#setdiff(dll1short$english, coefs$en$definition) 

# are these items also on the short form CDIs?
#length(intersect(dll1short$english, wg_short_en$word)) # all of the WG
#length(intersect(dll1short$english, ws_short_enA$word)) # 36 of the WS
```

```{r match-spanish-words}
# use with SP WG short form (12-18 mos)
#dll1SPshort <- read_csv(here("DLL/DLL-ES1-short-Spanish.csv")) # 67 items

dll1short <- dll1short %>% # this is now 168 items...it has the WG short form included
  mutate(spanish = tolower(spanish)) %>%
  separate(col = spanish, into = c("spanish", NA), sep=" \\(") %>%
  # Expected 2 pieces. Additional pieces discarded in 4 rows [63, 90, 91, 159].Expected 2 pieces. Missing pieces filled with `NA` in 14 rows [13, 22, 27, 30, 36, 52, 54, 64, 66, 80, 88, 89, 129, 144].
  mutate(spanish = case_when(spanish == 'mamá/mami' ~ 'mamá',
                             spanish == 'calcetines' ~ 'calcetín',
                             spanish == 'tomar baño / bañarse' ~ 'baño', # verb -> noun.. tomar(se) ?
                             spanish == 'espera' ~ 'esperar(se)', # close enough ?
                             spanish == 'acabar(se)' ~ 'acabar',
                             spanish == 'no hay más' ~ 'no hay', # or "más" ?
                             spanish == 'rapido' ~ 'rápido (descriptive)', # or rápido (quantifiers)
                             spanish == 'lastimado' ~ 'lastimar(se)', # close enough ?
                             spanish == 'otro' ~ 'otro/otra vez', # close enough ?
                             spanish == 'quiquiriqui' ~ 'quiquiriquí', # DLL missing acent
                             spanish == 'brazos' ~ 'brazo',
                             spanish == 'manos' ~ 'mano',
                             spanish == 'vaso' ~ 'vasos',
                             spanish == 'llaves' ~ 'llave',
                             spanish == 'adiós/byebye' ~ 'adíos/byebye', # wordbank accent is incorrect
                             spanish == 'uno, dos, tres' ~ 'uno dos tres...',
                             spanish == 'shh' ~ 'shhh',
                             spanish == 'ver' ~ 'ver(se)',
                             spanish == '¿dónde está?' ~ 'dónde', # close enough ? 
                             TRUE ~ spanish))

dll1SPshort_num_matching = length(intersect(dll1short$spanish, coefs$sp$definition)) # was 59 on GK version
# 158 / 168
setdiff(dll1short$spanish, coefs$sp$definition)
# no match: tostada, alimentar, sonreír, algunos, también

# are these items also on the short form CDIs?
#length(intersect(dll1short$spanish, wg_short_sp$word)) # all of the WG
#length(intersect(dll1short$spanish, ws_short_sp$word)) # 63 of the WS

#dll1extended <- read_csv(here("DLL/DLL-ES1-extended-ENSP.csv")) #72 items
#dll1extended_EN_num_matching = length(intersect(dll1extended$word, coefs$en$definition))
#setdiff(dll1extended$word, coefs$en$definition) 
# DLL -> wordbank items
# toy -> toy (object)
# dress -> dress (object)
# ears -> ear
# clock/watch -> split to both "watch (object)" and "clock"
# swing -> swing (object)
dll1extended_SP_num_matching = length(intersect(dll1extended$translation, coefs$sp$definition)) # 61 (now 71)
#setdiff(dll1extended$translation, coefs$sp$definition) 
# DLL -> wordbank items
# pipi -> match with pipí ?? 
# globo -> globo/bomba
# plátano -> plátano/banana
# orejas -> oreja
# dedos -> dedo
# escalera -> escaleras
# bolsa -> bolsa (clothing)  [could also match bolsa (household) ??]
# tienda -> tienda/mercado
# papá* -> papá
# hacer la meme -> NO MATCH (only possible is "hacer"..)
# soplar/aventar -> split to "soplar" and "aventar"

# use with SP WS short form (18-30 mos)
dll2SPshort <- read_csv(here("DLL/DLL-ES2-short-Spanish.csv")) # 73 items
dll2SPshort_num_matching = length(intersect(dll2SPshort$word, coefs$sp$definition)) # 46 (now 54)
#setdiff(dll2SPshort$word, coefs$sp$definition) 
# no matches: juegos, el puré de manzana, coca, la galleta salada (tho galleta),
#  mentón, bandeja, trapeador, ir de compras, perseguir, abrazar, pretender/fingir,
#  rasgar, agitar, probar, chiquito, esta noche, al lado de, debajo, si (if)
# puede ('may', but poder (infinitive),
# escalera -> escaleras
# pierna -> piernas
# banco -> banco (outside)  (not "places")
# acabar/terminar -> split to "acabar" and "terminar"
# rápido -> rápido (descriptive)  ("fast": not (quantifiers))
# un/una -> split "un" / "una"

#setdiff(dll2SPshort$translation, coefs$en$definition)
# games -> game
# swing -> swing (object)
# hi/hello -> split to "hi" and "hello"
# at night -> "tonight" (wrong translation)

# use with EN WS short form (A or B??)
dll2ENshort <- read_csv(here("DLL/DLL-ES2-short-English.csv")) # 79
dll2ENshort_num_matching = length(intersect(dll2ENshort$word, coefs$en$definition)) # 67
#setdiff(dll2ENshort$word, coefs$en$definition) 
# no wordbank match: snake, drum, mustache, matches, pot, bell, godmother,
# let's go, know, turn off (tho "off" and "turn around"), win, in the morning (tho morning)

# "rain" is on both short WS form A and DLL-2 EN short 
intersect(ws_short_enA$word, dll2ENshort$word)
intersect(ws_short_enB$word, dll2ENshort$word) # 16 on DLL + short WS B: moo, truck, bottle, ..

load(here("data/wordbank_eng_ws_wg_webcdi31-36mos.Rds"))

too_young <- which(d_demo$age < 12) # 378 children can't be producing any words yet

d_demo_en = d_demo[-too_young,] 
d_mat_en = d_mat[-too_young,]

# DLL items not named the same
#dll1ENshort[which(!is.element(dll1ENshort$word, colnames(d_mat))),]
#dll1SPshort[which(!is.element(dll1SPshort$word, coefs$sp$definition)),] # tostada, 
```
Notes: the DLL lists *chicken*, whereas wordbank has both *chicken (food)* and *chicken (animal)*. Similar for *water* (beverage / not beverage both included in wordbank). 
We will use all related wordbank items in our analysis.
There were also a lot of plurals listed on the DLL that were singular in wordbank (e.g., ears/orejas, dedos/fingers).

English DLL items not in our wordbank IRT model: *one, two, three*, *family*, *drum*, *good morning*, *also*, and *many*.
Spanish DLL items not in our wordbank IRT model: *tostada*, *algunos*, *alimentar*, *sonreír*, *no hay más* (although we have *no* and *no hay*, as well as *más*), and lastimado (but we have *lastimar(se)*).

DLL2-Spanish has "esta noche" translated as "at night", but should be "tonight".
DLL also has "puede", a conjugation of infinitive verb *poder* (which is in Wordbank).
Wordbank and DLL also often disagree about plural, e.g. *escalera*, and *pierna* on the DLL correspond to *escaleras* and *piernas* in Wordbank. (See also *brazos* and *manos.*)

## Does the DLL short form recover full form scores?

### English DLL Level 1

Using data from `r nrow(subset(d_demo_en, age<19))` English-speaking children 12-18 month of age from Wordbank, we test how well sumscores from the DLL-ES1 short English form + CDI:WG short form predict children's  production scores from the full CDI (WG/WS).
The left panel shows full CDI scores vs. the DLL-ES1 short + CDI:WG short score, and the right panel shows the full CDI scores vs. just the CDI:WG short form score.

```{r cdi-short-DLL1-vs-full-cdi-English, echo=F, message=F, fig.width=8, fig.height=4}
en_dll_cols = na.omit(match(dll1ENshort$word, colnames(d_mat_en)))
en_wg_short_cols = na.omit(match(wg_short_en$word, colnames(d_mat_en)))
en_wg_short_dll_cols = union(en_wg_short_cols, en_dll_cols) # 163 items
d_demo_en$production = rowSums(d_mat_en, na.rm=T)
d_demo_en$DLLsum = rowSums(d_mat_en[,en_wg_short_dll_cols], na.rm=T)
d_demo_en$WGshort = rowSums(d_mat_en[,en_wg_short_cols], na.rm=T)

young_en = d_demo_en %>% filter(age <= 18, production < 396) # want only WG kids

dll_en_cor = cor(young_en$production, young_en$DLLsum) 

p1 <- young_en %>%
  ggplot(aes(x=production, y=DLLsum, group=sex, color=sex)) + 
  geom_point(alpha=.3) + theme_classic() + 
  xlab("Full CDI:WG Production Score") + ylab("CDI WG Short + DLL Score") + 
  geom_abline(slope=length(en_wg_short_dll_cols) / 395, intercept=0, linetype = 'dashed') +
  geom_smooth()

p2 <- young_en %>%
  ggplot(aes(x=production, y=WGshort, group=sex, color=sex)) + 
  geom_point(alpha=.3) + theme_classic() + 
  xlab("Full CDI:WG Production Score") + ylab("CDI WG Short Score") + 
  geom_abline(slope=length(en_wg_short_cols) / 395, intercept=0, linetype = 'dashed') +
  geom_smooth() + theme(legend.position = "none")
  
grid.arrange(p1, p2, nrow = 1, widths=c(4.5,3.9), heights=3.5)
```

Overall, the correlation of children's CDI:WG short + DLL scores and their full CDI production scores is quite high ($r=`r round(dll_en_cor,2)`$), but as shown above, for small vocabulary sizes the DLL score overestimates full CDI:WG production scores, while for higher full CDI:WG scores the DLL underestimates vocab size (dotted line has slope $=`r length(en_wg_short_dll_cols)` / `r 395`$).
However, the CDI:WG short form alone (right panel) shows a similar (and more extreme) overestimation for small vocabulary sizes.


### English DLL Level 2

Using data from `r nrow(subset(d_demo_en, age>15 & age<31))` English-speaking children 16-30 month of age from Wordbank, we test how well sumscores from the DLL-ES1 short English form + CDI:WG short form predict children's full production scores from the CDI:WS.
The left panel shows full CDI scores vs. the DLL-ES2 short + CDI:WS short form (A) score, and the right panel shows the full CDI scores vs. just the CDI:WG short form (A) score.

```{r cdi-short-DLL2-vs-full-cdi-English, echo=F, message=F, fig.width=8, fig.height=4}
en_dll2_cols = na.omit(match(dll2ENshort$word, colnames(d_mat_en)))
en_ws_short_cols = na.omit(match(ws_short_enA$word, colnames(d_mat_en))) # !! A and B forms for WS short
en_ws_short_dll_cols = union(en_ws_short_cols, en_dll2_cols) # 166 items
d_demo_en$production = rowSums(d_mat_en, na.rm=T)
d_demo_en$DLL2sum = rowSums(d_mat_en[,en_ws_short_dll_cols], na.rm=T)
d_demo_en$WSshort = rowSums(d_mat_en[,en_ws_short_cols], na.rm=T)

old_en = d_demo_en %>% filter(age > 15, age < 31)

dll2_en_cor = cor(old_en$production, old_en$DLLsum) 


p1 <- old_en %>% 
  ggplot(aes(x=production, y=DLL2sum, group=sex, color=sex)) + 
  geom_point(alpha=.1) + theme_classic() + 
  xlab("Full CDI Production Score") + ylab("CDI WS Short + DLL2 Score") + 
  geom_abline(slope=length(en_ws_short_dll_cols) / 680, intercept=0, linetype = 'dashed') +
  geom_smooth()

p2 <- old_en %>% 
  ggplot(aes(x=production, y=WSshort, group=sex, color=sex)) + 
  geom_point(alpha=.1) + theme_classic() + 
  xlab("Full CDI Production Score") + ylab("CDI WS Short Score") + 
  geom_abline(slope=length(en_ws_short_cols) / 680, intercept=0, linetype = 'dashed') +
  geom_smooth() + theme(legend.position = "none")

grid.arrange(p1, p2, nrow = 1, widths=c(4.5,3.9), heights=3.5)
```

Overall, the correlation of children's CDI:WS short + DLL2 scores and their full CDI production scores is quite high ($r=`r round(dll2_en_cor,2)`$), but as shown above, the DLL2 again mostly overestimates  production scores on the full CDI (dotted line has slope $=`r length(en_ws_short_dll_cols)` / `r 680`$).
In comparison, the CDI:WS short form (A) score only overestimates full CDI scores for smaller vocabulary sizes (<400).


### Spanish DLL Level 1

Now we look at overestimation for Spanish DLLs + CDI short forms.

```{r DLL-vs-full-score-Spanish, echo=F, message=F, fig.width=8, fig.height=4}
load(here("data/wordbank_sp_ws_wg_webcdi12-30mos.Rds"))
d_demo_sp = d_demo
d_mat_sp = d_mat
sp_dll_cols = na.omit(match(dll1SPshort$word, colnames(d_mat_sp))) # 61
#sp_wg_short_cols = na.omit(match(wg_short_sp$word, colnames(d_mat_sp)))
#sp_wg_short_dll_cols = union(sp_wg_short_cols, sp_dll_cols)

sp_dll2_cols = na.omit(match(dll2SPshort$word, colnames(d_mat_sp))) # 55

sp_wg_short_cols = na.omit(match(wg_short_sp$word, colnames(d_mat_sp)))
sp_ws_short_cols = na.omit(match(ws_short_sp$word, colnames(d_mat_sp)))


sp_wg_short_dll_cols = union(sp_wg_short_cols, sp_dll_cols) # 158
sp_ws_short_dll_cols = union(sp_ws_short_cols, sp_dll2_cols) # 153

d_demo_sp$production = rowSums(d_mat, na.rm=T)
d_demo_sp$DLL1sum = rowSums(d_mat_sp[,sp_wg_short_dll_cols], na.rm=T)
d_demo_sp$DLL2sum = rowSums(d_mat_sp[,sp_ws_short_dll_cols], na.rm=T)
d_demo_sp$WGshort = rowSums(d_mat_sp[,sp_wg_short_cols], na.rm=T)
d_demo_sp$WSshort = rowSums(d_mat_sp[,sp_ws_short_cols], na.rm=T)

young_sp <- d_demo_sp %>% filter(age<19, production<=428)
old_sp <- d_demo_sp %>% filter(age>15)

dll1_sp_cor = cor(young_sp$production, young_sp$DLL1sum) 
dll2_sp_cor = cor(old_sp$production, old_sp$DLL2sum) 

p1 <- young_sp %>% ggplot(aes(x=production, y=DLL1sum, group=sex, color=sex)) + 
  geom_point(alpha=.3) + theme_classic() + 
  xlab("Full CDI Production Score") + ylab("DLL1 Score") + 
  geom_abline(slope=length(sp_wg_short_dll_cols) / 428, intercept=0, linetype = 'dashed') +
  geom_smooth()

p2 <- young_sp %>% ggplot(aes(x=production, y=WGshort, group=sex, color=sex)) + 
  geom_point(alpha=.3) + theme_classic() + 
  xlab("Full CDI Production Score") + ylab("CDI WG Short Score") + 
  geom_abline(slope=length(sp_wg_short_cols) / 428, intercept=0, linetype = 'dashed') +
  geom_smooth() + theme(legend.position = "none")

grid.arrange(p1, p2, nrow = 1, widths=c(4.5,3.9), heights=3.5)
```


Using Wordbank data from `r nrow(young_sp)` Spanish-speaking children aged 12-18 months, we test how well sumscores from the DLL-ES1 short Spanish form correlate with children's full CDI:WG production scores.

As for English, the correlation of Spanish-speaking children's DLL scores and their full CDI:WG production scores is quite high ($r=`r round(dll1_sp_cor,2)`$), but as shown above, their DLL score overestimates the production score on the full CDI at smaller vocabulary sizes (dotted line has slope $=`r length(sp_dll_cols)` / `r 428`$).
Do note that few children in this dataset have large productive vocabularies.


### Spanish DLL Level 2

```{r spanish-dll2, echo=F, message=F, fig.width=8, fig.height=4}

p1 <- old_sp %>% ggplot(aes(x=production, y=DLL1sum, group=sex, color=sex)) + 
  geom_point(alpha=.3) + theme_classic() + 
  xlab("Full CDI Production Score") + ylab("DLL2 Score") + 
  geom_abline(slope=length(sp_ws_short_dll_cols) / 680, intercept=0, linetype = 'dashed') +
  geom_smooth()

p2 <- old_sp %>% ggplot(aes(x=production, y=WGshort, group=sex, color=sex)) + 
  geom_point(alpha=.3) + theme_classic() + 
  xlab("Full CDI Production Score") + ylab("CDI WS Short Score") + 
  geom_abline(slope=length(sp_ws_short_cols) / 680, intercept=0, linetype = 'dashed') +
  geom_smooth() + theme(legend.position = "none")

grid.arrange(p1, p2, nrow = 1, widths=c(4.5,3.9), heights=3.5)

```


## Recommendations

Overall, it seems that many of the items on the DLL are somewhat easier than average, and thus these forms tend to overestimate children's full CDI scores (indeed, for items on the DLL1 English short form, the average easiness is -0.89, while the mean easiness of items not on the DLL is -1.85).
This is also true of the CDI:WG short English form: the average easiness is -0.19 and the average ease of items not on the WG short form is -1.98.
The CDI:WS short English form (A) is less biased towards easy items: average easiness is -1.29 vs. -1.82 for items not on the short WS.
The histograms below show the distribution of easiness parameters for English (left) and Spanish (right) CDI words. 
Solid lines show the average ease of DLL items (DLL 1 = red, DLL 2 = orange), and dashed lines show the average of non-DLL items.

Spanish DLL1 items have an average ease of -0.96, while other items on the full CDI have a mean ease of -2.02.
The Spanish DLL2 shows the least bias: items on it have an average ease of -1.75, while other CDI items have a mean of -1.94.


```{r, echo=F, message=F, fig.width=8, fig.height=4}
en_dll1_ease <- coefs$en %>% mutate(onDLL = 
                  ifelse(is.element(definition, dll1ENshort$word), 1, 0)) %>%
  group_by(onDLL) %>% 
  summarise(easiness=mean(d), n=n())

en_dll2_ease <- coefs$en %>% mutate(onDLL = 
                  ifelse(is.element(definition, dll2ENshort$word), 1, 0)) %>%
  group_by(onDLL) %>% 
  summarise(easiness=mean(d), n=n())

en_wg_short_ease <- coefs$en %>% mutate(onWGshort = 
                          ifelse(is.element(definition, wg_short_en$word), 1, 0)) %>%
  group_by(onWGshort) %>% 
  summarise(easiness=mean(d), n=n())

en_ws_short_ease <- coefs$en %>% mutate(onWSshort = 
                          ifelse(is.element(definition, ws_short_enA$word), 1, 0)) %>%
  group_by(onWSshort) %>% 
  summarise(easiness=mean(d), n=n())

sp_dll1_ease <- coefs$sp %>% mutate(onDLL = 
                  ifelse(is.element(definition, dll1SPshort$word), 1, 0)) %>%
  group_by(onDLL) %>% 
  summarise(easiness=mean(d), n=n())

sp_dll2_ease <- coefs$sp %>% mutate(onDLL = 
                  ifelse(is.element(definition, dll2SPshort$word), 1, 0)) %>%
  group_by(onDLL) %>% 
  summarise(easiness=mean(d), n=n())


p1 <- ggplot(coefs$en, aes(x=d)) + geom_histogram() + theme_bw() + 
  xlab("English Item Easiness") + 
  geom_vline(xintercept=en_dll1_ease$easiness, color="red", linetype=c("dashed","solid")) +
  geom_vline(xintercept=en_dll2_ease$easiness, color="orange", linetype=c("dashed","solid"))
p2 <- ggplot(coefs$sp, aes(x=d)) + geom_histogram() + theme_bw() + 
  xlab("Spanish Item Easiness") + 
  geom_vline(xintercept=sp_dll1_ease$easiness, color="red", linetype=c("dashed","solid")) +
  geom_vline(xintercept=sp_dll2_ease$easiness, color="orange", linetype=c("dashed","solid"))

grid.arrange(p1, p2, nrow = 1, widths=c(4,4), heights=3)
```


We recommend bringing the overall mean estimated IRT difficulty of the words selected for the DLLs closer to the mean difficulty of the words on the rest of the CDI.

To start, we examine IRT easiness parameters for the doublets on the existing DLL lists, looking for large itmes with large mismatch between their English and Spanish ease.

## Do doublets have similar difficulties?

We want to whether assess doublet items have similar difficulty (operationalized by their IRT parameters) in English and in Spanish. 
For example, consider if "perro" was for some reason much more difficult than "dog", then you wouldn't want to include it because it wouldn't be a good item for estimating vocabulary overlap!

I've entered the English translation-equivalent item for the Spanish DLL1 items.
Below are shown the parameters for these items, (en_d = English easiness, sp_d = Spanish easiness), ordered by the most to least discrepant (difficulty difference squared).
(_a1 columns show item discriminations (slopes), and sp_en_d_diff simply shows Spanish - English easiness)
Clearly some of these items have quite different difficulty levels, e.g. *hat* is much easier than *sombrero* (and somewhat easier than *gorra*).
We may want to pick a criterion for the maximum allowable discrepancy, and try to find items that are more equivalent.

```{r compare-doublet-difficulties-dll1, echo=F}
# a1 = discrimination, d = difficulty, g = lower-bound, u = upper-bound

pars_dll <- dll1SPshort %>% 
  left_join(coefs$sp, by=c("word"="definition")) %>% 
  select(-g, -u, -notes) %>% 
  rename(sp_a1 = a1, sp_d = d) %>% 
  left_join(coefs$en, by=c("translation"="definition")) %>%
  select(-g, -u) %>% 
  rename(en_a1 = a1, en_d = d)

pars_dll <- pars_dll %>% 
  mutate(sp_en_d_diff = sp_d - en_d,
         d_diff_sq = (sp_d - en_d)^2) %>% 
  filter(!is.na(d_diff_sq)) %>%
  arrange(desc(d_diff_sq))
knitr::kable(pars_dll, digits=2)

#pars_dll %>% ggplot(aes(x=en_d, y=sp_d)) +
#  geom_point() + theme_minimal() # geom_text_repel() # but can only use 1lang..
```

### DLL Level 2

```{r compare-doublet-difficulties-dll2, echo=F}
# a1 = discrimination, d = difficulty, g = lower-bound, u = upper-bound

pars_dll2 <- dll2SPshort %>% 
  left_join(coefs$sp, by=c("word"="definition")) %>% 
  select(-g, -u, -notes) %>% 
  rename(sp_a1 = a1, sp_d = d) %>% 
  left_join(coefs$en, by=c("translation"="definition")) %>%
  select(-g, -u) %>% 
  rename(en_a1 = a1, en_d = d)

pars_dll2 <- pars_dll2 %>% 
  mutate(sp_en_d_diff = sp_d - en_d,
         d_diff_sq = (sp_d - en_d)^2) %>% 
  filter(!is.na(d_diff_sq)) %>%
  arrange(desc(d_diff_sq))
knitr::kable(pars_dll2, digits=2)
```

## Recommended Item Swaps

We will use Wordbank's unilemmas to find translation-equivalent pairs that have smaller d_diff_sq values than current DLL items.
We first get the English / Spanish unilemmas from wordbank (both WS and WG), and below simply show the Spanish vs. English easiness parameters.

```{r unilemmas, echo=F, message=F}
# created in get_L1-L2_unilemmas.R
load("data/English-Spanish-dict.Rdata")

# add unilemmas to DLL dfs
dll1ENshort <- dll1ENshort %>% 
  left_join(dict %>% select(english, uni_lemma, d_diff_sq, en_d, sp_d, lexical_class), by=c("word"="english")) %>% select(-notes) %>%
  group_by(word) %>% arrange(d_diff_sq) %>% slice(1) %>% ungroup() # just take item with minimal easiness difference

dll2ENshort <- dll2ENshort %>% 
  left_join(dict %>% select(english, uni_lemma, d_diff_sq, en_d, sp_d, lexical_class), by=c("word"="english")) %>% select(-notes) %>%
  group_by(word) %>% arrange(d_diff_sq) %>% slice(1) %>% ungroup()

dll1SPshort <- dll1SPshort %>% 
  left_join(dict %>% select(spanish, uni_lemma, d_diff_sq, en_d, sp_d, lexical_class), by=c("word"="spanish")) %>% select(-notes) %>%
  group_by(word) %>% arrange(d_diff_sq) %>% slice(1) %>% ungroup()

dll2SPshort <- dll2SPshort %>% 
  left_join(dict %>% select(spanish, uni_lemma, d_diff_sq, en_d, sp_d, lexical_class), by=c("word"="spanish")) %>% select(-notes) %>%
  group_by(word) %>% arrange(d_diff_sq) %>% slice(1) %>% ungroup()

dict %>% ggplot(aes(x=en_d, y=sp_d, color=lexical_class)) + 
  geom_abline(slope=1, intercept=0, linetype = "dashed") +
  geom_point() + geom_smooth(method='lm') + theme_bw() +
  xlab("English word easiness") + ylab("Spanish word easiness")

Nswaps = 15
```

Working with `r nrow(dict)` unilemmas that match both our English and Spanish IRT parameters.
For each DLL list we will simply swap the N=`r Nswaps` items with the largest easiness difference for items with minimal easiness difference.
We also attempt to find replacement items of the same lexical class.
We report the original DLL list's easiness SSE, as well as the improvement in (easiness SSE) after each swap is made.


```{r optimization-functions, echo=F}
# penalize for 1. overestimation of vocab size relative to full CDI
# 2. sum of squared difference in item difficulties

# find item with biggest squared difference and select a new pair with a small difference
# with smaller (est?) difference (and same lexical category?)
# with high k, almost always chooses argmax
propose_swap <- function(cur_list, dictn, k=5, match_lexical_class=T) {
  set.seed(42)
  item_to_replace = sample(1:nrow(cur_list), 1, prob=cur_list$d_diff_sq^k)
  if(match_lexical_class) {
    tmp = subset(dictn, lexical_class == cur_list[item_to_replace,]$lexical_class)
    if(nrow(tmp)>0) dictn = tmp 
  }
  replacement = sample(1:nrow(dictn), 1, prob = 1/dictn$d_diff_sq^k)
  improvement = cur_list[item_to_replace,]$d_diff_sq - dictn[replacement,]$d_diff_sq
  if(improvement <= 0) {
    print("No better word found!")
    return(list())
  }
  print(paste0("Replacing '", cur_list[item_to_replace,]$uni_lemma,"' with '", 
               dictn[replacement,]$uni_lemma,"' (SSE improvement = ",round(improvement,2),")"))
  return(list(remove = cur_list[item_to_replace,], 
              add = dictn[replacement,]))
}

# for each DLL list, propose a number of swaps
improve_DLL_list <- function(cur_list, dict, Nswaps = 10, language="english") {
  unilingual_items <- subset(cur_list, is.na(uni_lemma))
  dict_novel <- subset(dict, !is.element(uni_lemma, cur_list$uni_lemma))
  cur_list <- na.omit(cur_list) 
  print(paste("Original list item easiness SSE:",round(sum(cur_list$d_diff_sq), 2)))
  print(paste("Mean Spanish item easiness:",round(mean(cur_list$sp_d), 2)))
  print(paste("Mean English item easiness:",round(mean(cur_list$en_d), 2)))
  # remove items from dict that are already on DLL list
  print(paste("Selecting from",nrow(dict_novel),"words on both Eng/Sp CDIs that are not on the DLL."))
  removed = c()
  added = c()
  for(i in 1:Nswaps) {
     swap = propose_swap(cur_list, dict_novel, k=5)
     if(length(swap)>0) {
      removed = rbind(removed, swap$remove)
      added = rbind(added, swap$add)
      # remove added word from dict
      dict_novel = subset(dict_novel, uni_lemma!=swap$add$uni_lemma)
      # remove removed word from DLL
      cur_list = subset(cur_list, uni_lemma!=swap$remove$uni_lemma)
      swap$remove
      swap$add$word = unlist(swap$add[,language])
      tmp = swap$add %>%
        select(word, uni_lemma, lexical_class, d_diff_sq, en_d, sp_d)
      cur_list = rbind(cur_list, tmp)
     }
  }
  print(paste("New list item easiness SSE:",round(sum(cur_list$d_diff_sq), 2)))
  print(paste("Mean Spanish item easiness:",round(mean(cur_list$sp_d), 2)))
  print(paste("Mean English item easiness:",round(mean(cur_list$en_d), 2)))
  
  return(list(new_list = rbind(cur_list, unilingual_items), added = added, removed = removed))
}

```

## English Level 1 DLL

```{r}
new_dll1ENshort <- improve_DLL_list(dll1ENshort, dict, Nswaps=Nswaps, language="english")$new_list
write.csv(new_dll1ENshort, file="DLL/new_DLL-ES1-short-English.csv")
```

Even swapping only 10 items reduced the total SSE by more than 50%.
Although it was not optimized for, the average ease of the items also decreased for both languages, coming closer to the mean.
We now do the same for the other DLL forms before determining whether the DLL overestimation has decreased.

## English Level 2 DLL

```{r}
new_dll2ENshort <- improve_DLL_list(dll2ENshort, dict, Nswaps=Nswaps, language="english")$new_list
write.csv(new_dll2ENshort, file="DLL/new_DLL-ES2-short-English.csv")
```

## Spanish Level 1 DLL

```{r}
new_dll1SPshort <- improve_DLL_list(dll1SPshort %>% select(-translation), dict, Nswaps=Nswaps, language="spanish")$new_list
write.csv(new_dll1SPshort, file="DLL/new_DLL-ES1-short-Spanish.csv")
```

Note especially that the average ease of English items on this list was originally quite high (-0.29 vs. Spanish's -0.78), but it is somewhat closer to the mean ease of the Spanish items after the substitutions.

## Spanish Level 2 DLL

```{r}
new_dll2SPshort <- improve_DLL_list(dll2SPshort %>% select(-translation), dict, Nswaps=Nswaps, language="spanish")$new_list
write.csv(new_dll2SPshort, file="DLL/new_DLL-ES2-short-Spanish.csv")
```

Much like the previous list, after substitutions the mean ease of the English items is closer to those of the Spanish items. 

## Overestimation in new DLL lists


```{r new-overestimation, echo=F, warning=F, message=F}

plot_dll_vs_full_cdi <- function(dll, cdi_short, d_demo, d_mat, young=T, plot=F, max_voc) {
  dll_cols = na.omit(match(dll$word, colnames(d_mat)))
  cdi_short_cols = na.omit(match(cdi_short$word, colnames(d_mat)))
  cdi_short_dll_cols = union(cdi_short_cols, dll_cols) # 163 items
  d_demo$production = rowSums(d_mat, na.rm=T)
  d_demo$DLLsum = rowSums(d_mat[,cdi_short_dll_cols], na.rm=T)
  d_demo$CDIshort = rowSums(d_mat[,cdi_short_cols], na.rm=T)
  
  if(young) {
    d_demo <- d_demo %>% filter(age>=12, age <= 18, production <= max_voc)
  } else {
    d_demo <- d_demo %>% filter(age >= 16)
  }
  
  # extrapolate based on max_voc to full CDI score
  d_demo$adjDLLsum = (d_demo$DLLsum * max_voc) / length(cdi_short_dll_cols)
  d_demo$adjCDIshort = (d_demo$CDIshort * max_voc) / length(cdi_short_cols) 
    
  DLL_rel = psych::ICC(d_demo[,c("production","adjDLLsum")]) 
  CDIshort_rel = psych::ICC(d_demo[,c("production","adjCDIshort")]) 

  DLL_rmse <- d_demo %>% mutate(DLL_rmse = sqrt((production - adjDLLsum)^2),
                    CDIshort_rmse = sqrt((production - adjCDIshort)^2)) %>% 
    summarise(DLL_rmse = mean(DLL_rmse), CDIshort_rmse = mean(CDIshort_rmse))
  
  if(plot) {
    p1 <- d_demo %>%
      ggplot(aes(x=production, y=DLLsum, group=sex, color=sex)) + 
      geom_point(alpha=.3) + theme_classic() + 
      xlab("Full CDI Production Score") + ylab("CDI Short + DLL Score") + 
      geom_abline(slope=length(cdi_short_dll_cols) / max_voc, intercept=0, linetype = 'dashed') +
      geom_smooth()
    
    p2 <- d_demo %>%
      ggplot(aes(x=production, y=CDIshort, group=sex, color=sex)) +
      geom_point(alpha=.3) + theme_classic() +
      xlab("Full CDI Production Score") + ylab("CDI Short Score") +
      geom_abline(slope=length(cdi_short_cols) / max_voc, intercept=0, linetype = 'dashed') +
      geom_smooth() + theme(legend.position = "none")
    
    grid.arrange(p1, p2, nrow = 1, widths=c(4.5,3.9), heights=3.5)
  }
  return(list(DLL_rel=DLL_rel, CDIshort_rel=CDIshort_rel, DLL_rmse=DLL_rmse))
}

report_new_dll <- function(dll_str, new_rel) {
  row <- c(new_rel$DLL_rel$results$ICC[1], new_rel$CDIshort_rel$results$ICC[1], new_rel$DLL_rmse)
  row <- c(dll_str, row)
  names(row) = c("DLL", "DLL vs. full ICC1", "CDI short vs. full ICC1", "DLL vs. full RMSE", "CDI short vs. full RMSE")
  return(data.frame(row))
}
```
The new DLL1 English short form (left) certainly looks like it's overestimating less (compare to just the CDI:WG short form).
We quantify the reliability (ICC1) and the overall root mean squared error (RMSE) of the new DLL form + CDI short form, just the CDI short form, and of the old DLL form.


```{r, echo=F}
new_dll1EN_rel <- plot_dll_vs_full_cdi(new_dll1ENshort, wg_short_en, d_demo_en, d_mat_en, young=T, plot=T, max_voc=395)
new_dll2EN_rel <- plot_dll_vs_full_cdi(new_dll2ENshort, ws_short_enA, d_demo_en, d_mat_en, young=F, max_voc=680)
new_dll1_SP_rel <- plot_dll_vs_full_cdi(new_dll1SPshort, wg_short_sp, d_demo_sp, d_mat_sp, young=T, max_voc=428)
new_dll2_SP_rel <- plot_dll_vs_full_cdi(new_dll2SPshort, ws_short_sp, d_demo_sp, d_mat_sp, young=F, max_voc=680)

# get old DLL reliability
old_dll1EN_rel <- plot_dll_vs_full_cdi(dll1ENshort, wg_short_en, d_demo_en, d_mat_en, young=T, max_voc=395)
old_dll2EN_rel <- plot_dll_vs_full_cdi(dll2ENshort, ws_short_enA, d_demo_en, d_mat_en, young=F, max_voc=680)
old_dll1_SP_rel <- plot_dll_vs_full_cdi(dll1SPshort, wg_short_sp, d_demo_sp, d_mat_sp, young=T, max_voc=428)
old_dll2_SP_rel <- plot_dll_vs_full_cdi(dll2SPshort, ws_short_sp, d_demo_sp, d_mat_sp, young=F, max_voc=680)

# problem: a few missing items in each new_dll: 89 vs 95; 82 vs 85; 70 vs 79..
# is that why we see slightly lower reliability / RMSE in the original DLLs?? 

dll_rel_tab <- rbind(report_new_dll("Old DLL1 EN short", old_dll1EN_rel),
                     report_new_dll("New DLL1 EN short", new_dll1EN_rel),
                     report_new_dll("Old DLL2 EN short", old_dll2EN_rel),
                     report_new_dll("New DLL2 EN short", new_dll2EN_rel), 
                     report_new_dll("Old DLL1 SP short", old_dll1_SP_rel),
                     report_new_dll("New DLL1 SP short", new_dll1_SP_rel),
                     report_new_dll("Old DLL2 SP short", old_dll2_SP_rel),
                     report_new_dll("New DLL2 SP short", new_dll2_SP_rel))
```

The table below shows that the reliability of the original (old) DLLs vs. the (new) DLL with swaps is the same for extrapolating to children's full CDI scores (column: DLL.vs..full.ICC1), and higher than the reliability of extrapolating full CDI scores from just the appropriate short CDI form (column: CDI.short.vs..full.ICC1).
The RMSE of the new DLL forms vs. the old DLL forms improved in all cases except for the the DLL1 SP short form, which was marginally worse (new RMSE=12.60 vs. old RMSE=12.22).
For all DLL forms (new and old), the RMSE is better than that achieved by extrapolating from the CDI short form (column: CDI.short.vs..full.RMSE).

```{r, echo=F}
knitr::kable(dll_rel_tab, digits=2)
```



## Summary

For each of the DLL lists, swapping the `r Nswaps` items with the largest discrepancy between English and Spanish easiness for items of minimal discrepancy within the same lexical class resulted in substantially reducing the total easiness SSE, and also resulted in mean item easiness (in both languages) that are more equal and closer to the means of each language, and thus generally better for extrapolating to children's full CDI score. 
Recognizing that these swaps are chosen algorithmically, we recommend the DLL team to consider each of the above swaps and determine whether any key words have been removed, or whether any undesirable words have been added.